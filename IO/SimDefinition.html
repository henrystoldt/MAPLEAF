<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>MAPLEAF.IO.SimDefinition API documentation</title>
<meta name="description" content="Contains a class meant to read, write and modify simulation definition (.mapleaf) files, the master dictionary of
default values for simulation …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.IO.SimDefinition</code></h1>
</header>
<section id="section-intro">
<p>Contains a class meant to read, write and modify simulation definition (.mapleaf) files, the master dictionary of
default values for simulation definitions, and a few utility functions for working with string dictionary keys</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Created by Henry Stoldt
# January 2019

&#39;&#39;&#39; 
Contains a class meant to read, write and modify simulation definition (.mapleaf) files, the master dictionary of 
default values for simulation definitions, and a few utility functions for working with string dictionary keys
&#39;&#39;&#39;
import random
import re
import shlex
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Union

from MAPLEAF.Motion.CythonVector import Vector

#################### Default value dictionary  #########################
defaultConfigValues = {
    &#34;MonteCarlo.output&#34;:                                    &#34;landingLocations&#34;,

    &#34;SimControl.plot&#34;:                                      &#34;Position Velocity AngularVelocity FlightAnimation&#34;,
    &#34;SimControl.loggingLevel&#34;:                              &#34;2&#34;,
    &#34;SimControl.EndCondition&#34;:                              &#34;Altitude&#34;,
    &#34;SimControl.EndConditionValue&#34;:                         &#34;-1&#34;,
    &#34;SimControl.StageDropPaths.compute&#34;:                    &#34;true&#34;,
    &#34;SimControl.StageDropPaths.endCondition&#34;:               &#34;Altitude&#34;,
    &#34;SimControl.StageDropPaths.endConditionValue&#34;:          &#34;0&#34;,
    &#34;SimControl.timeDiscretization&#34;:                        &#34;RK45Adaptive&#34;,
    &#34;SimControl.timeStep&#34;:                                  &#34;0.01&#34;,
    &#34;SimControl.TimeStepAdaptation.controller&#34;:             &#34;PID&#34;,
    &#34;SimControl.TimeStepAdaptation.targetError&#34;:            &#34;0.001&#34;,
    &#34;SimControl.TimeStepAdaptation.minFactor&#34;:              &#34;0.3&#34;,
    &#34;SimControl.TimeStepAdaptation.maxFactor&#34;:              &#34;1.5&#34;,
    &#34;SimControl.TimeStepAdaptation.Elementary.safetyFactor&#34;:&#34;0.9&#34;,
    &#34;SimControl.TimeStepAdaptation.maxTimeStep&#34;:            &#34;30&#34;,
    &#34;SimControl.TimeStepAdaptation.minTimeStep&#34;:            &#34;0.0001&#34;,
    &#34;SimControl.TimeStepAdaptation.PID.coefficients&#34;:       &#34;-0.01 -0.001 0&#34;,
    &#34;SimControl.TimeStepAdaptation.eventTimingAccuracy&#34;:    &#34;0.001&#34;,
    &#34;SimControl.RocketPlot&#34;:                                &#34;Off&#34;,

    &#34;Environment.EarthModel&#34;:                           &#34;Flat&#34;,
    &#34;Environment.AtmosphericPropertiesModel&#34;:           &#34;USStandardAtmosphere&#34;,
    &#34;Environment.LaunchSite.elevation&#34;:                 &#34;0&#34;,
    &#34;Environment.LaunchSite.railLength&#34;:                &#34;0&#34;,
    &#34;Environment.LaunchSite.latitude&#34;:                  &#34;0&#34;,
    &#34;Environment.LaunchSite.longitude&#34;:                 &#34;0&#34;,
    &#34;Environment.MeanWindModel&#34;:                        &#34;Constant&#34;,
    &#34;Environment.ConstantMeanWind.velocity&#34;:            &#34;(0 0 0)&#34;,
    &#34;Environment.SampledGroundWindData.launchMonth&#34;:    &#34;Yearly&#34;,
    &#34;Environment.SampledRadioSondeData.launchMonth&#34;:    &#34;Yearly&#34;,
    &#34;Environment.Hellman.alphaCoeff&#34;:                   &#34;0.1429&#34;,
    &#34;Environment.Hellman.altitudeLimit&#34;:                &#34;1000&#34;,
    &#34;Environment.TurbulenceModel&#34;:                      &#34;None&#34;,
    &#34;Environment.turbulenceOffWhenUnderChute&#34;:          &#34;True&#34;,

    &#34;Environment.ConstantAtmosphere.temp&#34;:              &#34;15&#34;,
    &#34;Environment.ConstantAtmosphere.pressure&#34;:          &#34;101325&#34;,
    &#34;Environment.ConstantAtmosphere.density&#34;:           &#34;1.225&#34;,
    &#34;Environment.ConstantAtmosphere.viscosity&#34;:         &#34;1.789e-5&#34;,
    &#34;Environment.TabulatedAtmosphere.filePath&#34;:         &#34;MAPLEAF/ENV/US_STANDARD_ATMOSPHERE.txt&#34;,
    
    &#34;Rocket.HIL.quatUpdateRate&#34;:                        &#34;100&#34;,
    &#34;Rocket.HIL.posUpdateRate&#34;:                         &#34;20&#34;,
    &#34;Rocket.HIL.velUpdateRate&#34;:                         &#34;20&#34;,
    &#34;Rocket.HIL.teensyComPort&#34;:                         &#34;COM20&#34;,
    &#34;Rocket.HIL.imuComPort&#34;:                            &#34;COM15&#34;,
    &#34;Rocket.HIL.teensyBaudrate&#34;:                        &#34;9600&#34;,
    &#34;Rocket.HIL.imuBaudrate&#34;:                           &#34;57600&#34;,

    &#34;Rocket.ControlSystem.desiredFlightDirection&#34;:      &#34;(0 0 1)&#34;,
    &#34;Rocket.ControlSystem.MomentController.Type&#34;:       &#34;GainScheduledPIDRocket&#34;,
    &#34;Rocket.ControlSystem.updateRate&#34;:                  &#34;0&#34;,

    &#34;Rocket.name&#34;:                                      &#34;Rocket&#34;,
    &#34;Rocket.position&#34;:                                  &#34;(0 0 10)&#34;,
    &#34;Rocket.initialDirection&#34;:                          &#34;(0 0 1)&#34;,
    &#34;Rocket.velocity&#34;:                                  &#34;(0 0 0)&#34;,
    &#34;Rocket.angularVelocity&#34;:                           &#34;(0 0 0)&#34;,

    &#34;Rocket.Aero.fullyTurbulentBL&#34;:                     &#34;true&#34;,
    &#34;Rocket.Aero.addZeroLengthBoatTailsToAccountForBaseDrag&#34;:&#34;true&#34;,
    &#34;Rocket.Aero.surfaceRoughness&#34;:                     &#34;0.000005&#34;,

    &#34;Stage.stageNumber&#34;:                                &#34;0&#34;,
    &#34;Stage.separationTriggerType&#34;:                      &#34;None&#34;,
    &#34;Stage.separationTriggerValue&#34;:                     &#34;0&#34;,
    &#34;Stage.separationDelay&#34;:                            &#34;0&#34;,
    &#34;Stage.position&#34;:                                   &#34;(0 0 0)&#34;,

    &#34;AeroForce.Lref&#34;:                                   &#34;0&#34;,
    &#34;AeroForce.Cd&#34;:                                     &#34;0&#34;,
    &#34;AeroForce.Cl&#34;:                                     &#34;0&#34;,
    &#34;AeroForce.momentCoeffs&#34;:                           &#34;(0 0 0)&#34;,

    &#34;AeroDamping.zDampingCoeffs&#34;:                       &#34;(0 0 0)&#34;,
    &#34;AeroDamping.yDampingCoeffs&#34;:                       &#34;(0 0 0)&#34;,
    &#34;AeroDamping.xDampingCoeffs&#34;:                       &#34;(0 0 0)&#34;,

    &#34;FinSet.finCantAngle&#34;:                              &#34;0&#34;,
    &#34;FinSet.firstFinAngle&#34;:                             &#34;0&#34;,
    &#34;FinSet.LeadingEdge.shape&#34;:                         &#34;Round&#34;,
    &#34;FinSet.TrailingEdge.shape&#34;:                        &#34;Tapered&#34;,
    &#34;FinSet.numFinSpanSlicesForIntegration&#34;:            &#34;10&#34;,

    &#34;BoatTail.shape&#34;:                                   &#34;cone&#34;,

    &#34;Mass.cg&#34;:                                          &#34;(0 0 0)&#34;,

    &#34;Motor.impulseAdjustFactor&#34;:                        &#34;1.0&#34;,
    &#34;Motor.burnTimeAdjustFactor&#34;:                       &#34;1.0&#34;,
    
    &#34;Actuator.controller&#34;:                              &#34;TableInterpolating&#34;,
    &#34;Actuator.responseModel&#34;:                           &#34;FirstOrder&#34;,
    &#34;Actuator.responseTime&#34;:                            &#34;0.1&#34;,

    &#34;RecoverySystem.cg&#34;:                                &#34;(0 0 0)&#34;,

    &#34;TabulatedAeroForce.Lref&#34;:                          &#34;0&#34;,
    
    &#34;testValue.testDefaultValue1&#34;:                      &#34;asdf&#34;,
    &#34;testDefaultValue2&#34;:                                &#34;jkl;&#34;
}

simDefinitionHelpMessage = \
&#34;&#34;&#34;
    All non-empty, non-comment lines are expected to end in either:
    {   (dictionary start)
    }   (dictionary end)
    
    Or to contain a space-separated key-value pair:
    key value
&#34;&#34;&#34;
class SimDefinition():
    
    #### Parsing / Initialization ####
    def __init__(self, fileName=None, dictionary=None, disableDistributionSampling=False, silent=False, defaultDict=None):
        &#39;&#39;&#39;
        Parse simulation definition files into a dictionary of string values accessible by string keys.

        Inputs:
            * fileName: (str) path to simulation definition file
            * dictionary: (dict[str,str]) if not providing a fileName, provide a pre-parsed dictionary equivalent to a simulation definition file
            * disableDistributionSampling: (bool) Turn Monte Carlo sampling of normally-distributed parameters on/off
            * silent: (bool) Console output control
            * defaultDict: (dict[str,str] provide a custom dictionary of default values. If none is provided, defaultConfigValues is used.)
        
        Example:
            The file contents:  
                &#39;SimControl{  
                    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;timeDiscretization RK4;  
                }&#39;  
            Would be parsed into a single-key Python dictionary, stored in self.dict:  
            `{ &#34;SimControl.timeDiscretization&#34;: &#34;RK4&#34;}`
        
        &#39;&#39;&#39;
        self.silent = silent
        &#39;&#39;&#39; Boolean, controls console output &#39;&#39;&#39;

        self.disableDistributionSampling = disableDistributionSampling
        &#39;&#39;&#39; Boolean - controls whether parameters which have standard deviations specified are actually sampled from a normal distribution. If True, the mean value is always returned. Chief use case for disabling sampling: Checking simulation convergence as the time step / target error is decreased. &#39;&#39;&#39;

        self.dict = None # type: Dict[str:str]
        &#39;&#39;&#39; Main dictionary of values, usually populated from a simulation definition file &#39;&#39;&#39;

        self.defaultDict = None
        &#39;&#39;&#39; Holds all of the defined default values. These will fill in for missing values in self.dict. Unless a different dictionary is specified, will hold a reference to `MAPLEAF.IO.SimDefinition.defaultConfigValues` &#39;&#39;&#39;
        
        self.monteCarloLogger = None 
        &#39;&#39;&#39; Filled in by  Main.runMonteCarloSimulation() if running  Monte Carlo simulation. Type: `IO.Logging.MonteCarloLogger` &#39;&#39;&#39;

        # Assign default dictionary
        if defaultDict == None:
            self.defaultDict = defaultConfigValues
        else:
            self.defaultDict = defaultDict

        # Parse/Assign main values dictionary
        if fileName != None:
            self._parseSimDefinitionFile(fileName)
        elif dictionary != None:
            self.dict = dictionary
            self.fileName=fileName
        else:
            raise ValueError(&#34;No fileName or dictionary provided to initialize the SimDefinition&#34;)

        # Initialize tracking of default values used and unaccessed keys
        self._resetUsedAndUnusedKeyTrackers()

        # Initialize instance of random.Random for Monte Carlo sampling
        if not disableDistributionSampling:
            try:
                randomSeed = self.getValue(&#34;MonteCarlo.randomSeed&#34;)
            except KeyError:
                randomSeed = random.randrange(1000000)
            
            if not silent:
                print(&#34;Monte Carlo random seed: {}&#34;.format(randomSeed))
            self.rng = random.Random(randomSeed)
            &#39;&#39;&#39; Instace of random.Random owned by this instance of SimDefinition. Random seed can be specified by the MonteCarlo.randomSeed parameter. Used for sampling all normal distributions for parameters that have std dev specified. &#39;&#39;&#39;

    def _parseDictionaryContents(self, workingText, startLine, currDictName, allowKeyOverwriting=False) -&gt; int:
        &#39;&#39;&#39; 
            Parses an individual subdictionary in a simdefinition file.
            Calls itself recursively to parse further sub dictionaries.
            Saves parsed key-value pairs to self.dict

            Returns index of next line to parse
        &#39;&#39;&#39;
        i = startLine

        while i &lt; len(workingText):
            line = workingText[i]
            
            if line.split()[0] == &#34;!create&#34;:
                # Parse derived subdictionary
                i = self._parseDerivedDictionary(workingText, i, currDictName)

            elif line.strip()[-1] == &#39;{&#39;:
                # Parse regular Subdictionary
                subDictName = line.strip()[:-1] # Remove whitespace and dict start bracket
                
                # Recursive call to parse subdictionary
                if currDictName == &#34;&#34;:
                    i = self._parseDictionaryContents(workingText, i+1, subDictName, allowKeyOverwriting)
                else:
                    i = self._parseDictionaryContents(workingText, i+1, currDictName + &#34;.&#34; + subDictName, allowKeyOverwriting)

            elif line.strip() == &#39;}&#39;:
                #End current dictionary - continue parsing at next line
                return i
                        
            elif len(line.split()) &gt; 1:
                #Add a key value pair
                keyVal = line.split()
                
                # Save the space-separated key-value pair
                key = keyVal[0]
                value = &#34; &#34;.join(keyVal[1:])
                if currDictName == &#34;&#34;:
                    keyString = key
                else:
                    keyString = currDictName + &#34;.&#34; + key

                if not keyString in self.dict or allowKeyOverwriting:
                    self.dict[keyString] = value
                else:
                    raise ValueError(&#34;Duplicate Key: &#34; + keyString + &#34; in File: &#34; + self.fileName)
            
            else:
                # Error: Line not recognized as a dict start/end or a key/value pair
                print(simDefinitionHelpMessage)
                raise ValueError(&#34;Problem reading line {}&#34;.format(line))

            # Next line
            i += 1

    def _parseDerivedDictionary(self, workingText, initializationLine, currDictName) -&gt; int:
        &#39;&#39;&#39;
            Parse a &#39;derived&#39; subdictionary, defined with the !create command in .mapleaf files

            Inputs:
                workingText: (list[str]) lines of text in .mapleaf file
                initializationLine: (int) index of line defining the derived dictionary to be parsed in workingText
                currDictName: (str) name of the dictionary containing the derived dictionary to be parsed. &#34;&#34; if at root level

            Returns:
                (int): index of the last line in the derived subdictionary
        &#39;&#39;&#39;
        # workingText[initializationLine] should be something like:
            # &#39;    !create SubDictionary2 from Dictionary1.SubDictionary1{&#39;
        definitionLine = workingText[initializationLine].split()
        if currDictName == &#39;&#39;:
            derivedDictName = definitionLine[1]
        else:
            derivedDictName = currDictName + &#39;.&#39; + definitionLine[1]

        # Parent dict is last command. Remove opening curly bracket (last character)
        parentDictName = definitionLine[-1][:-1]

        # Fill out temporary dict, after applying all modifiers, add values to main self.dict
        derivedDict = {}

        #### Get keys from parent dict ####
        keysInParentDict = self.getSubKeys(parentDictName)
        
        if len(keysInParentDict) == 0:
            raise ValueError(&#34;ERROR: Dictionary to derive from: {} is not defined before {} in {}.&#34;.format(parentDictName, derivedDictName, self.fileName))

        for parentKey in keysInParentDict:
            key = parentKey.replace(parentDictName, derivedDictName)
            derivedDict[key] = self.dict[parentKey]

        #### Apply additional commands ####
        i = initializationLine + 1
        while i &lt; len(workingText):
            line = workingText[i]
            possibleCommand = line.split()[0]

            if possibleCommand == &#34;!replace&#34;:
                # Replace some text in the keys/values of the derived dictionary
                replaceCommand = shlex.split(line)

                # Get string to replace (w/o quotations)
                toReplace = replaceCommand[1].replace(&#34;&#39;&#34;, &#34;&#34;)
                toReplace = toReplace.replace(&#39;&#34;&#39;, &#34;&#34;)

                # Get string to replace it with (w/o quotation)
                replaceWith = replaceCommand[-1].replace(&#34;&#39;&#34;, &#34;&#34;)
                replaceWith = replaceWith.replace(&#39;&#34;&#39;, &#34;&#34;)

                derivedDictAfterReplace = {}
                for key in derivedDict:
                    newKey = key.replace(toReplace, replaceWith)
                    # .pop() gets the old value and also deletes it from the dictionary
                    newValue = derivedDict[key].replace(toReplace, replaceWith)
                    derivedDictAfterReplace[newKey] = newValue

                derivedDict = derivedDictAfterReplace

            elif possibleCommand == &#34;!removeKeysContaining&#34;:
                removeCommand = shlex.split(line)
                stringToDelete = removeCommand[1]

                # Search for and remove any keys that contain stringToDelete
                keysToDelete = []
                for key in derivedDict:
                    if stringToDelete in key:
                        keysToDelete.append(key)

                for key in keysToDelete:
                    del derivedDict[key]                

            elif line[0] != &#34;!&#34;:
                # Done commands - let the regular parser handle the rest
                break

            else:
                raise ValueError(&#34;Command: {} not implemented. Try using !replace or !removeKeysContaining&#34;.format(line.split()[0]))

            i += 1

        #### Add derivedDict values to self.dict ####
        for key in derivedDict:
            # Make sure we don&#39;t clobber existing values with poorly thought-out replace commands
            if key not in self.dict:
                self.dict[key] = derivedDict[key]
            else:
                raise ValueError(&#34;Derived dict key {} already exists&#34;.format(key, self.fileName))

        #### Parse any regular values in derived dict ####
        return self._parseDictionaryContents(workingText, i, derivedDictName, allowKeyOverwriting=True)

    def _replaceMAPLEAFRelativeFilePathsWithAbsolutePaths(self):
        &#39;&#39;&#39; 
            Right after parsing a sim definition file, replaces paths relative to the MAPLEAF installation directory with absolute paths.
            This allows MAPLEAF to work when installed from pip and being run outside its installation directory.
        &#39;&#39;&#39;
        for key in self.dict:
            # Iterate over all keys, looking for file path relative to the MAPLEAF repo
            val = self.dict[key]

            if len(val) &gt; 8 and val[:8] == &#34;MAPLEAF/&#34;:
                # Replace the relative path with an absolute one
                self.dict[key] = getAbsoluteFilePath(val)

    def _parseSimDefinitionFile(self, fileName):
        self.fileName = fileName
        self.dict = {}
        
        # Read all of the file&#39;s contents
        file = open(fileName, &#34;r+&#34;)
        workingText = file.read()
        file.close()
        
        # Remove comments
        comment = re.compile(&#34;#.*&#34;) 
        workingText = re.sub(comment, &#34;&#34;, workingText)
        
        # Remove blank lines
        workingText = [line for line in workingText.split(&#39;\n&#39;) if line.strip() != &#39;&#39;]
        
        # Start recursive parse by asking to parse the root-level dictionary
        self._parseDictionaryContents(workingText, 0, &#34;&#34;)

        self._replaceMAPLEAFRelativeFilePathsWithAbsolutePaths()

    #### Normal Usage ####
    def getValue(self, key: str) -&gt; str:
        &#34;&#34;&#34;
            Input:
                Key should be a string of format &#34;DictionaryName.SubdictionaryName.Key&#34;
            Output:
                Always returns a string value
                Returns value from defaultConfigValues if key not present in current SimDefinition&#39;s dictionary

                Normal Distribution Sampling:
                    If (key + &#34;_stdDev&#34;) exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
                        Where the mean of the normal distribution is taken to be the value of &#39;key&#39; and the standard deviation of the distribution is the value of &#39;key_stdDev&#39;
                        For a vector value, a vector of standard deviations is expected
                    For repeatable sampling, set the value &#34;MonteCarlo.randomSeed&#34; in the file loaded by this class
        &#34;&#34;&#34;
        # Remove any whitespace from the key
        key = key.strip()

        ### Find string/mean value ###
        if self.dict.__contains__(key):
            stringValue = self.dict[key]

            if key in self.unaccessedFields: # Track which keys are accessed
                self.unaccessedFields.remove(key)
        elif key in self.defaultDict:
            stringValue = self.defaultDict[key]
            self.defaultValuesUsed.add(key)
        else:
            # Check if there&#39;s a class-based default value to return
            classBasedDefaultValue = self._getClassBasedDefaultValue(key)
            
            if classBasedDefaultValue != None:
                stringValue = classBasedDefaultValue
            else:
                raise KeyError(&#34;Key: &#34; + key + &#34; not found in {} or default config values&#34;.format(self.fileName))

        ### Sample from normal distribution if required ###
        if not self.disableDistributionSampling:
            ### Check if a standard deviation has been specified. If so, sample a gaussian distribution before returning the value ###
            stdDevKey = key + &#34;_stdDev&#34;

            # Scalar values
            try:
                mu = float(stringValue)            
                sigma = float(self.getValue(stdDevKey))

                sampledValue = self.rng.gauss(mu, sigma)

                logLine = &#34;Sampling scalar parameter: {}, value: {:1.3f}&#34;.format(key, sampledValue)
                if self.monteCarloLogger != None:
                    self.monteCarloLogger.log(logLine)
                elif not self.silent:
                    print(logLine)


                return str(sampledValue)
            except (KeyError, ValueError):
                # KeyError throws if stdDevKey not present
                # ValueError throws if either conversion to float fails
                pass

            # Vector values
            try:
                muVec = Vector(stringValue)
                sigmaVec = Vector(self.getValue(stdDevKey))

                sampledVec = Vector(*[ self.rng.gauss(mu, sigma) for mu, sigma in zip(muVec, sigmaVec)])

                logLine = &#34;Sampling vector parameter: {}, value: ({:1.3f})&#34;.format(key, sampledVec)
                if self.monteCarloLogger != None:
                    self.monteCarloLogger.log(logLine)
                elif not self.silent:
                    print(logLine)

                return str(sampledVec)
            except (KeyError, ValueError):
                # KeyError throws if stdDevKey not present
                # ValueError throws if either conversion to Vector fails
                pass

        ### Otherwise return original string value ###
        return stringValue

    def setValue(self, key: str, value) -&gt; None:
        &#39;&#39;&#39;
            Will add the entry if it&#39;s not present
        &#39;&#39;&#39;
        # Remove whitespace
        key = key.strip()
        
        self.dict[key] = value

    def removeKey(self, key: str):
        if key in self.dict:
            return self.dict.pop(key)
        else:
            print(&#34;Warning: &#34; + key + &#34; not found, can&#39;t delete&#34;)
            return None

    def setIfAbsent(self, key: str, value):
        &#39;&#39;&#39; Sets a value, only if it doesn&#39;t currently exist in the dictionary &#39;&#39;&#39;
        if not key in self.dict:
            self.setValue(key, value)

    def writeToFile(self, fileName: str, writeHeader=True) -&gt; None:
        &#39;&#39;&#39; 
            Write a (potentially modified) sim definition to file.
            Newly written file will not contain any comments! 
        &#39;&#39;&#39;
        self.fileName = fileName

        with open(fileName, &#39;w&#39;) as file:
            # Extract the fileName from the fileName variable, which may contain other folder names
            dictName = re.sub(&#34;^.*/&#34;, &#34;&#34;, fileName)

            # Write Header
            if writeHeader:
                file.write(&#34;# MAPLEAF\n&#34;)
                file.write(&#34;# File: {}\n&#34;.format(fileName))
                file.write(&#34;# Autowritten on: &#34; + str(datetime.now()) + &#34;\n&#34;)

            # Sorting the keys before iterating through them ensures that dictionaries will be stored together
            sortedDict = sorted(self.dict.items())
            currDicts = []
            for key in sortedDict:
                key = key[0]
                dicts = key.split(&#39;.&#39;)[:-1]

                # Need to get be in the appropriate dictionary before writing the key, value pair
                if dicts != currDicts:
                    
                    #Close any uneeded dictionaries
                    dictDepth = currDicts.__len__()
                    while dictDepth &gt; 0:
                        if dictDepth &gt; dicts.__len__():
                            file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                        elif currDicts[dictDepth-1] != dicts[dictDepth-1]:
                            file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                        else:
                            break
                        
                        dictDepth = dictDepth - 1

                    openedNewDict = False

                    #Open any new dictionaries
                    while dictDepth &lt; dicts.__len__():
                        newDict = dicts[dictDepth]
                        file.write(&#34;\n&#34; + &#34;\t&#34; * dictDepth + newDict + &#34;{\n&#34;)
                        dictDepth = dictDepth + 1
                        openedNewDict = True
                    
                    if not openedNewDict:
                        # If no new dictionary was openend after closing unneeded ones, add a spacing line before writing keys/values
                        file.write(&#34;\n&#34;)

                    currDicts = dicts

                #Add the key, value
                dictDepth = currDicts.__len__()
                realKey = re.sub(&#34;^([^\.]*\.)+&#34;, &#34;&#34;, key)
                file.write( &#34;\t&#34;*dictDepth + realKey + &#34;\t&#34; + self.dict[key] + &#34;\n&#34;)

            #Close any open dictionaries
            dictDepth = currDicts.__len__()
            while dictDepth &gt; 0:
                dictDepth = dictDepth - 1
                file.write(&#34;\t&#34;*dictDepth + &#34;}\n&#34;)

    #### Introspection / Key Gymnastics ####
    def findKeysContaining(self, keyContains: List[str]) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns a list of all keys that contain any of the strings in keyContains
            
            ## Example  
                findKeysContaining([&#34;class&#34;]) -&gt;  
                [ &#34;Rocket.class&#34;, &#34;Rocket.Sustainer.class&#34;, &#34;Rocket.Sustainer.Nosecone.class&#34;, etc... ]
        &#39;&#39;&#39;
        matchingKeys = []
        for key in self.dict.keys():
            match = True
            for str in keyContains:
                if str not in key:
                    match = False
                    break
            
            if match:
                matchingKeys.append(key)
        
        if len(matchingKeys) &gt; 0:
            return matchingKeys
        else:
            return None

    def getSubKeys(self, key: str) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns a list of all keys that are children of key

            ## Example  
                getSubKeys(&#34;Rocket&#34;) -&gt;  
                [ &#34;Rocket.position&#34;, &#34;Rocket.Sustainer.NoseCone.mass&#34;, &#34;Rocket.Sustainer.RecoverySystem.position&#34;, etc... ]
        &#39;&#39;&#39;
        subKeys = []
        for currentKey in self.dict.keys():
            if isSubKey(key, currentKey):
                subKeys.append(currentKey)
        
        return subKeys

    def getImmediateSubKeys(self, key: str) -&gt; List[str]:
        &#34;&#34;&#34; 
            Returns all keys that are immediate children of the parentKey (one &#39;level&#39; lower)
            
            .. note:: Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries

            ## Example:
                getImmediateSubKeys(&#34;Rocket&#34;) -&gt;  
                [ &#34;Rocket.name&#34;, &#34;Rocket.position&#34;, &#34;Rocket.velocity&#34;, etc...]
        &#34;&#34;&#34;
        results = set()
        for potentialChildKey in self.dict.keys():
            # Iterate through all keys - check if they are children of currentPath
            if isSubKey(key, potentialChildKey):
                # If so, get the part of the key that is the immediate child of currentPath
                immediateSubkey = getImmediateSubKey(key, potentialChildKey)
                
                # If we haven&#39;t got it already, save it
                results.add(immediateSubkey)

        return list(results)

    def getImmediateSubDicts(self, key: str) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns list of names of immediate subdictionaries

            ## Example
                getImmediateSubDicts(&#34;Rocket&#34;) -&gt;
                [ &#34;Rocket.StageOne&#34;, &#34;Rocket.StageTwo&#34;, &#34;Rocket.ControlSystem&#34;, etc... ]

            .. note:: This example would not return a dictionry like: &#34;Rocket.StageOne.FinSet&#34; because it&#39;s not an immediate subdictionary of &#34;Rocket&#34;
        &#39;&#39;&#39;
        keyLevel = getKeyLevel(key)
        subKeys = self.getSubKeys(key)

        subDictionaries = set()
        for subKey in subKeys:
            subKeyLevel = getKeyLevel(subKey)
            if subKeyLevel - keyLevel &gt; 1:
                # A subkey would have 1 level higher
                # A subkey of a subdictionary would have 2 levels higher - this is what we&#39;re looking for
                subDictKey = getParentKeyAtLevel(subKey, keyLevel+1)
                subDictionaries.add(subDictKey)
        
        return list(subDictionaries)

    def _getClassBasedDefaultValue(self, key: str) -&gt; Union[str, None]:
        &#39;&#39;&#39; 
            Returns class-based default value from defaultConfigValues if it exists. Otherwise returns None 
            
            Will attempt to find class-based default values for every longer prefixes of a key:
                key = &#34;Rocket.Sustainer.canards.trailingEdge.shape&#34;
                Attempt1 = &#34;Rocket.Sustainer.canards.trailingEdge.class&#34; -&gt; Fail
                Attempt2 = &#34;Rocket.Sustainer.canards.class&#34; -&gt; FinSet -&gt; look up &#39;FinSet.trailingEdge.shape&#39; in defaultDict -&gt; if there, return it, otherwise return None
        &#39;&#39;&#39;
        splitLevel = getKeyLevel(key)

        while splitLevel &gt;= 0:
            prefix, suffix = splitKeyAtLevel(key, splitLevel)
            
            try:
                classKey = prefix + &#34;.class&#34;
                className = self.dict[classKey]                

                # As soon as we arrive at an item with a class, search terminates
                try:
                    classBasedDefaultKey = className + &#34;.&#34; + suffix
                    defaultValue = self.defaultDict[classBasedDefaultKey]

                    # Track that we&#39;ve used a default value
                    if classBasedDefaultKey not in self.defaultValuesUsed:
                        self.defaultValuesUsed.add(classBasedDefaultKey)
                    
                    # if the classKey was useful, count it as &#39;used&#39;
                    if classKey in self.unaccessedFields: 
                        self.unaccessedFields.remove(classKey)
                        
                    return defaultValue
                except KeyError:
                    return None # class-based default value not found
            
            except KeyError:
                pass # prefix.class not present

            # Move one level up the dictionary for next attempt
            splitLevel -= 1
        
        return None

    #### Usage Reporting ####
    def printUnusedKeys(self):
        &#39;&#39;&#39;
            Checks which keys in the present simulation definition have not yet been accessed.
            Prints a list of those to the console.
        &#39;&#39;&#39;
        if len(self.unaccessedFields) &gt; 0:
            print(&#34;\nWarning: The following keys were loaded from: {} but never accessed:&#34;.format(self.fileName))
            for key in sorted(self.unaccessedFields):
                value = self.dict[key]
                print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
            print(&#34;&#34;)

    def printDefaultValuesUsed(self):
        &#39;&#39;&#39;
            Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.
        &#39;&#39;&#39;
        if len(self.defaultValuesUsed):
            print(&#34;\nWarning: The following default values were used in this simulation:&#34;)
            for key in sorted(self.defaultValuesUsed):
                value = self.defaultDict[key]
                print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
            print(&#34;\nIf this was not intended, override the default values by adding the above information to your simulation definition file.\n&#34;)
        
    def _resetUsedAndUnusedKeyTrackers(self):
        # Create a dictionary to keep track of which attributed have been accessed (initially none)
        self.unaccessedFields = set(self.dict.keys())
        # Create a list to track which default values have been used
        self.defaultValuesUsed = set()

    #### Utilities ####
    def __str__(self):
        result = &#34;&#34;
        result += &#34;File: &#34; + self.fileName + &#34;\n&#34;

        for key, value in self.dict.items():
            result += &#34;{}: {}\n&#34;.format(key, value)

        result += &#34;\n&#34;

        return result

    def __eq__ (self, simDef2):
        try:
            if self.dict == simDef2.dict:
                return True
            else:
                return False
        except AttributeError:
            return False

################### Functions for dealing with string keys ########################
def isSubKey(potentialParent:str, potentialChild:str) -&gt; bool:
    &#34;&#34;&#34;
        ## Example 
        `isSubKey(&#34;Rocket&#34;, &#34;Rocket.name&#34;)` -&gt; True
        `isSubKey(&#34;SimControl&#34;, &#34;Rocket.name&#34;)` -&gt; False
    &#34;&#34;&#34;
    pLength = len(potentialParent)
    cLength = len(potentialChild)

    if cLength &lt;= pLength:
        return False
    elif potentialChild[:pLength] == potentialParent:
        return True
    else:
        return False

def getKeyLevel(key:str) -&gt; int:
    &#34;&#34;&#34;
        Sums the number of dots in the key 
        ## Example 
            getKeyLevel(&#34;Rocket&#34;) -&gt; 0  
            getKeyLevel(&#34;Rocket.name&#34;) -&gt; 1
    &#34;&#34;&#34;
    if len(key) == 0:
        return -1
    else:
        return len(key.split(&#39;.&#39;))-1

def getParentKeyAtLevel(key:str, desiredLevel:int) -&gt; str:
    &#34;&#34;&#34;
        &gt;&gt;&gt; getParentKeyAtLevel(&#39;Rocket.Sustainer.Nosecone.mass&#39;, 0)
        &#39;Rocket&#39;
        &gt;&gt;&gt; getParentKeyAtLevel(&#39;Rocket.Sustainer.Nosecone.mass&#39;, 1)
        &#39;Rocket.Sustainer&#39;
        &gt;&gt;&gt; getParentKeyAtLevel(&#39;Rocket.Sustainer.Nosecone.mass&#39;, 2)
        &#39;Rocket.Sustainer.Nosecone&#39;
    &#34;&#34;&#34;
    desiredParts = key.split(&#39;.&#39;)[0:desiredLevel+1]
    return &#39;.&#39;.join(desiredParts)

def getImmediateSubKey(parent, child):
    &#34;&#34;&#34; 
        Takes the parent key, adds one level of the child key:  

        ## Example
        &gt;&gt;&gt; getImmediateSubKey(&#39;Rocket&#39;, &#39;Rocket.Sustainer.name&#39;)
        &#39;Rocket.Sustainer&#39;
    &#34;&#34;&#34;
    if not isSubKey(parent, child):
        raise ValueError(&#34;{} is not a subkey of {}&#34;.format(child, parent))

    parentKeyPlusOneLevel, _ = splitKeyAtLevel(child, getKeyLevel(parent)+1)
    return parentKeyPlusOneLevel

def splitKeyAtLevel(key:str, prefixLevel:int) -&gt; Tuple[str]:
    &#39;&#39;&#39; 
        0 &lt;= level &lt;= getKeyLevel(key)
        ### Example
        &gt;&gt;&gt; splitKeyAtLevel(&#34;Rocket&#34;, 0)
        (&#39;Rocket&#39;, &#39;&#39;)
        &gt;&gt;&gt; splitKeyAtLevel(&#34;Rocket.Sustainer&#34;, 0)
        (&#39;Rocket&#39;, &#39;Sustainer&#39;)
        &gt;&gt;&gt; splitKeyAtLevel(&#34;Rocket.Sustainer.position&#34;, 1)
        (&#39;Rocket.Sustainer&#39;, &#39;position&#39;)
    &#39;&#39;&#39;
    n = prefixLevel + 1
    keyNames = key.split(&#39;.&#39;)
    prefix = &#34;.&#34;.join(keyNames[:n])
    suffix = &#34;.&#34;.join(keyNames[n:])
    return prefix, suffix

def getAbsoluteFilePath(relativePath: str) -&gt; str:
    &#39;&#39;&#39; 
        Takes a path defined relative to the MAPLEAF repository and tries to return an absolute path for the current installation.
        Returns original relativePath if an absolute path is not found
    &#39;&#39;&#39;
    # This file is at MAPLEAF/IO/SimDefinition, so MAPLEAF&#39;s install directory is three levels up
    pathToMAPLEAFInstallation = Path(__file__).parent.parent.parent

    relativePath = Path(relativePath)
    absolutePath = pathToMAPLEAFInstallation / relativePath

    if absolutePath.exists:
        return str(absolutePath)
    else:
        print(&#34;WARNING: Unable to compute absolute path replacement for a path which is suspected to be relative to the MAPLEAF installation location: {}&#34;.format(relativePath))
        return relativePath</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MAPLEAF.IO.SimDefinition.getAbsoluteFilePath"><code class="name flex">
<span>def <span class="ident">getAbsoluteFilePath</span></span>(<span>relativePath: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a path defined relative to the MAPLEAF repository and tries to return an absolute path for the current installation.
Returns original relativePath if an absolute path is not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAbsoluteFilePath(relativePath: str) -&gt; str:
    &#39;&#39;&#39; 
        Takes a path defined relative to the MAPLEAF repository and tries to return an absolute path for the current installation.
        Returns original relativePath if an absolute path is not found
    &#39;&#39;&#39;
    # This file is at MAPLEAF/IO/SimDefinition, so MAPLEAF&#39;s install directory is three levels up
    pathToMAPLEAFInstallation = Path(__file__).parent.parent.parent

    relativePath = Path(relativePath)
    absolutePath = pathToMAPLEAFInstallation / relativePath

    if absolutePath.exists:
        return str(absolutePath)
    else:
        print(&#34;WARNING: Unable to compute absolute path replacement for a path which is suspected to be relative to the MAPLEAF installation location: {}&#34;.format(relativePath))
        return relativePath</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getImmediateSubKey"><code class="name flex">
<span>def <span class="ident">getImmediateSubKey</span></span>(<span>parent, child)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the parent key, adds one level of the child key:
</p>
<h2 id="example">Example</h2>
<pre><code class="python-repl">&gt;&gt;&gt; getImmediateSubKey('Rocket', 'Rocket.Sustainer.name')
'Rocket.Sustainer'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubKey(parent, child):
    &#34;&#34;&#34; 
        Takes the parent key, adds one level of the child key:  

        ## Example
        &gt;&gt;&gt; getImmediateSubKey(&#39;Rocket&#39;, &#39;Rocket.Sustainer.name&#39;)
        &#39;Rocket.Sustainer&#39;
    &#34;&#34;&#34;
    if not isSubKey(parent, child):
        raise ValueError(&#34;{} is not a subkey of {}&#34;.format(child, parent))

    parentKeyPlusOneLevel, _ = splitKeyAtLevel(child, getKeyLevel(parent)+1)
    return parentKeyPlusOneLevel</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getKeyLevel"><code class="name flex">
<span>def <span class="ident">getKeyLevel</span></span>(<span>key: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Sums the number of dots in the key </p>
<h2 id="example">Example</h2>
<pre><code>getKeyLevel("Rocket") -&gt; 0  
getKeyLevel("Rocket.name") -&gt; 1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKeyLevel(key:str) -&gt; int:
    &#34;&#34;&#34;
        Sums the number of dots in the key 
        ## Example 
            getKeyLevel(&#34;Rocket&#34;) -&gt; 0  
            getKeyLevel(&#34;Rocket.name&#34;) -&gt; 1
    &#34;&#34;&#34;
    if len(key) == 0:
        return -1
    else:
        return len(key.split(&#39;.&#39;))-1</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getParentKeyAtLevel"><code class="name flex">
<span>def <span class="ident">getParentKeyAtLevel</span></span>(<span>key: str, desiredLevel: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="python-repl">&gt;&gt;&gt; getParentKeyAtLevel('Rocket.Sustainer.Nosecone.mass', 0)
'Rocket'
&gt;&gt;&gt; getParentKeyAtLevel('Rocket.Sustainer.Nosecone.mass', 1)
'Rocket.Sustainer'
&gt;&gt;&gt; getParentKeyAtLevel('Rocket.Sustainer.Nosecone.mass', 2)
'Rocket.Sustainer.Nosecone'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getParentKeyAtLevel(key:str, desiredLevel:int) -&gt; str:
    &#34;&#34;&#34;
        &gt;&gt;&gt; getParentKeyAtLevel(&#39;Rocket.Sustainer.Nosecone.mass&#39;, 0)
        &#39;Rocket&#39;
        &gt;&gt;&gt; getParentKeyAtLevel(&#39;Rocket.Sustainer.Nosecone.mass&#39;, 1)
        &#39;Rocket.Sustainer&#39;
        &gt;&gt;&gt; getParentKeyAtLevel(&#39;Rocket.Sustainer.Nosecone.mass&#39;, 2)
        &#39;Rocket.Sustainer.Nosecone&#39;
    &#34;&#34;&#34;
    desiredParts = key.split(&#39;.&#39;)[0:desiredLevel+1]
    return &#39;.&#39;.join(desiredParts)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.isSubKey"><code class="name flex">
<span>def <span class="ident">isSubKey</span></span>(<span>potentialParent: str, potentialChild: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h2 id="example">Example</h2>
<p><code>isSubKey("Rocket", "Rocket.name")</code> -&gt; True
<code>isSubKey("SimControl", "Rocket.name")</code> -&gt; False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isSubKey(potentialParent:str, potentialChild:str) -&gt; bool:
    &#34;&#34;&#34;
        ## Example 
        `isSubKey(&#34;Rocket&#34;, &#34;Rocket.name&#34;)` -&gt; True
        `isSubKey(&#34;SimControl&#34;, &#34;Rocket.name&#34;)` -&gt; False
    &#34;&#34;&#34;
    pLength = len(potentialParent)
    cLength = len(potentialChild)

    if cLength &lt;= pLength:
        return False
    elif potentialChild[:pLength] == potentialParent:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.splitKeyAtLevel"><code class="name flex">
<span>def <span class="ident">splitKeyAtLevel</span></span>(<span>key: str, prefixLevel: int) ‑> Tuple[str]</span>
</code></dt>
<dd>
<div class="desc"><p>0 &lt;= level &lt;= getKeyLevel(key)</p>
<h3 id="example">Example</h3>
<pre><code class="python-repl">&gt;&gt;&gt; splitKeyAtLevel(&quot;Rocket&quot;, 0)
('Rocket', '')
&gt;&gt;&gt; splitKeyAtLevel(&quot;Rocket.Sustainer&quot;, 0)
('Rocket', 'Sustainer')
&gt;&gt;&gt; splitKeyAtLevel(&quot;Rocket.Sustainer.position&quot;, 1)
('Rocket.Sustainer', 'position')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splitKeyAtLevel(key:str, prefixLevel:int) -&gt; Tuple[str]:
    &#39;&#39;&#39; 
        0 &lt;= level &lt;= getKeyLevel(key)
        ### Example
        &gt;&gt;&gt; splitKeyAtLevel(&#34;Rocket&#34;, 0)
        (&#39;Rocket&#39;, &#39;&#39;)
        &gt;&gt;&gt; splitKeyAtLevel(&#34;Rocket.Sustainer&#34;, 0)
        (&#39;Rocket&#39;, &#39;Sustainer&#39;)
        &gt;&gt;&gt; splitKeyAtLevel(&#34;Rocket.Sustainer.position&#34;, 1)
        (&#39;Rocket.Sustainer&#39;, &#39;position&#39;)
    &#39;&#39;&#39;
    n = prefixLevel + 1
    keyNames = key.split(&#39;.&#39;)
    prefix = &#34;.&#34;.join(keyNames[:n])
    suffix = &#34;.&#34;.join(keyNames[n:])
    return prefix, suffix</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition"><code class="flex name class">
<span>class <span class="ident">SimDefinition</span></span>
<span>(</span><span>fileName=None, dictionary=None, disableDistributionSampling=False, silent=False, defaultDict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse simulation definition files into a dictionary of string values accessible by string keys.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>fileName: (str) path to simulation definition file</li>
<li>dictionary: (dict[str,str]) if not providing a fileName, provide a pre-parsed dictionary equivalent to a simulation definition file</li>
<li>disableDistributionSampling: (bool) Turn Monte Carlo sampling of normally-distributed parameters on/off</li>
<li>silent: (bool) Console output control</li>
<li>defaultDict: (dict[str,str] provide a custom dictionary of default values. If none is provided, defaultConfigValues is used.)</li>
</ul>
<h2 id="example">Example</h2>
<p>The file contents:<br>
'SimControl{<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeDiscretization RK4;<br>
}'<br>
Would be parsed into a single-key Python dictionary, stored in self.dict:<br>
<code>{ "SimControl.timeDiscretization": "RK4"}</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimDefinition():
    
    #### Parsing / Initialization ####
    def __init__(self, fileName=None, dictionary=None, disableDistributionSampling=False, silent=False, defaultDict=None):
        &#39;&#39;&#39;
        Parse simulation definition files into a dictionary of string values accessible by string keys.

        Inputs:
            * fileName: (str) path to simulation definition file
            * dictionary: (dict[str,str]) if not providing a fileName, provide a pre-parsed dictionary equivalent to a simulation definition file
            * disableDistributionSampling: (bool) Turn Monte Carlo sampling of normally-distributed parameters on/off
            * silent: (bool) Console output control
            * defaultDict: (dict[str,str] provide a custom dictionary of default values. If none is provided, defaultConfigValues is used.)
        
        Example:
            The file contents:  
                &#39;SimControl{  
                    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;timeDiscretization RK4;  
                }&#39;  
            Would be parsed into a single-key Python dictionary, stored in self.dict:  
            `{ &#34;SimControl.timeDiscretization&#34;: &#34;RK4&#34;}`
        
        &#39;&#39;&#39;
        self.silent = silent
        &#39;&#39;&#39; Boolean, controls console output &#39;&#39;&#39;

        self.disableDistributionSampling = disableDistributionSampling
        &#39;&#39;&#39; Boolean - controls whether parameters which have standard deviations specified are actually sampled from a normal distribution. If True, the mean value is always returned. Chief use case for disabling sampling: Checking simulation convergence as the time step / target error is decreased. &#39;&#39;&#39;

        self.dict = None # type: Dict[str:str]
        &#39;&#39;&#39; Main dictionary of values, usually populated from a simulation definition file &#39;&#39;&#39;

        self.defaultDict = None
        &#39;&#39;&#39; Holds all of the defined default values. These will fill in for missing values in self.dict. Unless a different dictionary is specified, will hold a reference to `MAPLEAF.IO.SimDefinition.defaultConfigValues` &#39;&#39;&#39;
        
        self.monteCarloLogger = None 
        &#39;&#39;&#39; Filled in by  Main.runMonteCarloSimulation() if running  Monte Carlo simulation. Type: `IO.Logging.MonteCarloLogger` &#39;&#39;&#39;

        # Assign default dictionary
        if defaultDict == None:
            self.defaultDict = defaultConfigValues
        else:
            self.defaultDict = defaultDict

        # Parse/Assign main values dictionary
        if fileName != None:
            self._parseSimDefinitionFile(fileName)
        elif dictionary != None:
            self.dict = dictionary
            self.fileName=fileName
        else:
            raise ValueError(&#34;No fileName or dictionary provided to initialize the SimDefinition&#34;)

        # Initialize tracking of default values used and unaccessed keys
        self._resetUsedAndUnusedKeyTrackers()

        # Initialize instance of random.Random for Monte Carlo sampling
        if not disableDistributionSampling:
            try:
                randomSeed = self.getValue(&#34;MonteCarlo.randomSeed&#34;)
            except KeyError:
                randomSeed = random.randrange(1000000)
            
            if not silent:
                print(&#34;Monte Carlo random seed: {}&#34;.format(randomSeed))
            self.rng = random.Random(randomSeed)
            &#39;&#39;&#39; Instace of random.Random owned by this instance of SimDefinition. Random seed can be specified by the MonteCarlo.randomSeed parameter. Used for sampling all normal distributions for parameters that have std dev specified. &#39;&#39;&#39;

    def _parseDictionaryContents(self, workingText, startLine, currDictName, allowKeyOverwriting=False) -&gt; int:
        &#39;&#39;&#39; 
            Parses an individual subdictionary in a simdefinition file.
            Calls itself recursively to parse further sub dictionaries.
            Saves parsed key-value pairs to self.dict

            Returns index of next line to parse
        &#39;&#39;&#39;
        i = startLine

        while i &lt; len(workingText):
            line = workingText[i]
            
            if line.split()[0] == &#34;!create&#34;:
                # Parse derived subdictionary
                i = self._parseDerivedDictionary(workingText, i, currDictName)

            elif line.strip()[-1] == &#39;{&#39;:
                # Parse regular Subdictionary
                subDictName = line.strip()[:-1] # Remove whitespace and dict start bracket
                
                # Recursive call to parse subdictionary
                if currDictName == &#34;&#34;:
                    i = self._parseDictionaryContents(workingText, i+1, subDictName, allowKeyOverwriting)
                else:
                    i = self._parseDictionaryContents(workingText, i+1, currDictName + &#34;.&#34; + subDictName, allowKeyOverwriting)

            elif line.strip() == &#39;}&#39;:
                #End current dictionary - continue parsing at next line
                return i
                        
            elif len(line.split()) &gt; 1:
                #Add a key value pair
                keyVal = line.split()
                
                # Save the space-separated key-value pair
                key = keyVal[0]
                value = &#34; &#34;.join(keyVal[1:])
                if currDictName == &#34;&#34;:
                    keyString = key
                else:
                    keyString = currDictName + &#34;.&#34; + key

                if not keyString in self.dict or allowKeyOverwriting:
                    self.dict[keyString] = value
                else:
                    raise ValueError(&#34;Duplicate Key: &#34; + keyString + &#34; in File: &#34; + self.fileName)
            
            else:
                # Error: Line not recognized as a dict start/end or a key/value pair
                print(simDefinitionHelpMessage)
                raise ValueError(&#34;Problem reading line {}&#34;.format(line))

            # Next line
            i += 1

    def _parseDerivedDictionary(self, workingText, initializationLine, currDictName) -&gt; int:
        &#39;&#39;&#39;
            Parse a &#39;derived&#39; subdictionary, defined with the !create command in .mapleaf files

            Inputs:
                workingText: (list[str]) lines of text in .mapleaf file
                initializationLine: (int) index of line defining the derived dictionary to be parsed in workingText
                currDictName: (str) name of the dictionary containing the derived dictionary to be parsed. &#34;&#34; if at root level

            Returns:
                (int): index of the last line in the derived subdictionary
        &#39;&#39;&#39;
        # workingText[initializationLine] should be something like:
            # &#39;    !create SubDictionary2 from Dictionary1.SubDictionary1{&#39;
        definitionLine = workingText[initializationLine].split()
        if currDictName == &#39;&#39;:
            derivedDictName = definitionLine[1]
        else:
            derivedDictName = currDictName + &#39;.&#39; + definitionLine[1]

        # Parent dict is last command. Remove opening curly bracket (last character)
        parentDictName = definitionLine[-1][:-1]

        # Fill out temporary dict, after applying all modifiers, add values to main self.dict
        derivedDict = {}

        #### Get keys from parent dict ####
        keysInParentDict = self.getSubKeys(parentDictName)
        
        if len(keysInParentDict) == 0:
            raise ValueError(&#34;ERROR: Dictionary to derive from: {} is not defined before {} in {}.&#34;.format(parentDictName, derivedDictName, self.fileName))

        for parentKey in keysInParentDict:
            key = parentKey.replace(parentDictName, derivedDictName)
            derivedDict[key] = self.dict[parentKey]

        #### Apply additional commands ####
        i = initializationLine + 1
        while i &lt; len(workingText):
            line = workingText[i]
            possibleCommand = line.split()[0]

            if possibleCommand == &#34;!replace&#34;:
                # Replace some text in the keys/values of the derived dictionary
                replaceCommand = shlex.split(line)

                # Get string to replace (w/o quotations)
                toReplace = replaceCommand[1].replace(&#34;&#39;&#34;, &#34;&#34;)
                toReplace = toReplace.replace(&#39;&#34;&#39;, &#34;&#34;)

                # Get string to replace it with (w/o quotation)
                replaceWith = replaceCommand[-1].replace(&#34;&#39;&#34;, &#34;&#34;)
                replaceWith = replaceWith.replace(&#39;&#34;&#39;, &#34;&#34;)

                derivedDictAfterReplace = {}
                for key in derivedDict:
                    newKey = key.replace(toReplace, replaceWith)
                    # .pop() gets the old value and also deletes it from the dictionary
                    newValue = derivedDict[key].replace(toReplace, replaceWith)
                    derivedDictAfterReplace[newKey] = newValue

                derivedDict = derivedDictAfterReplace

            elif possibleCommand == &#34;!removeKeysContaining&#34;:
                removeCommand = shlex.split(line)
                stringToDelete = removeCommand[1]

                # Search for and remove any keys that contain stringToDelete
                keysToDelete = []
                for key in derivedDict:
                    if stringToDelete in key:
                        keysToDelete.append(key)

                for key in keysToDelete:
                    del derivedDict[key]                

            elif line[0] != &#34;!&#34;:
                # Done commands - let the regular parser handle the rest
                break

            else:
                raise ValueError(&#34;Command: {} not implemented. Try using !replace or !removeKeysContaining&#34;.format(line.split()[0]))

            i += 1

        #### Add derivedDict values to self.dict ####
        for key in derivedDict:
            # Make sure we don&#39;t clobber existing values with poorly thought-out replace commands
            if key not in self.dict:
                self.dict[key] = derivedDict[key]
            else:
                raise ValueError(&#34;Derived dict key {} already exists&#34;.format(key, self.fileName))

        #### Parse any regular values in derived dict ####
        return self._parseDictionaryContents(workingText, i, derivedDictName, allowKeyOverwriting=True)

    def _replaceMAPLEAFRelativeFilePathsWithAbsolutePaths(self):
        &#39;&#39;&#39; 
            Right after parsing a sim definition file, replaces paths relative to the MAPLEAF installation directory with absolute paths.
            This allows MAPLEAF to work when installed from pip and being run outside its installation directory.
        &#39;&#39;&#39;
        for key in self.dict:
            # Iterate over all keys, looking for file path relative to the MAPLEAF repo
            val = self.dict[key]

            if len(val) &gt; 8 and val[:8] == &#34;MAPLEAF/&#34;:
                # Replace the relative path with an absolute one
                self.dict[key] = getAbsoluteFilePath(val)

    def _parseSimDefinitionFile(self, fileName):
        self.fileName = fileName
        self.dict = {}
        
        # Read all of the file&#39;s contents
        file = open(fileName, &#34;r+&#34;)
        workingText = file.read()
        file.close()
        
        # Remove comments
        comment = re.compile(&#34;#.*&#34;) 
        workingText = re.sub(comment, &#34;&#34;, workingText)
        
        # Remove blank lines
        workingText = [line for line in workingText.split(&#39;\n&#39;) if line.strip() != &#39;&#39;]
        
        # Start recursive parse by asking to parse the root-level dictionary
        self._parseDictionaryContents(workingText, 0, &#34;&#34;)

        self._replaceMAPLEAFRelativeFilePathsWithAbsolutePaths()

    #### Normal Usage ####
    def getValue(self, key: str) -&gt; str:
        &#34;&#34;&#34;
            Input:
                Key should be a string of format &#34;DictionaryName.SubdictionaryName.Key&#34;
            Output:
                Always returns a string value
                Returns value from defaultConfigValues if key not present in current SimDefinition&#39;s dictionary

                Normal Distribution Sampling:
                    If (key + &#34;_stdDev&#34;) exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
                        Where the mean of the normal distribution is taken to be the value of &#39;key&#39; and the standard deviation of the distribution is the value of &#39;key_stdDev&#39;
                        For a vector value, a vector of standard deviations is expected
                    For repeatable sampling, set the value &#34;MonteCarlo.randomSeed&#34; in the file loaded by this class
        &#34;&#34;&#34;
        # Remove any whitespace from the key
        key = key.strip()

        ### Find string/mean value ###
        if self.dict.__contains__(key):
            stringValue = self.dict[key]

            if key in self.unaccessedFields: # Track which keys are accessed
                self.unaccessedFields.remove(key)
        elif key in self.defaultDict:
            stringValue = self.defaultDict[key]
            self.defaultValuesUsed.add(key)
        else:
            # Check if there&#39;s a class-based default value to return
            classBasedDefaultValue = self._getClassBasedDefaultValue(key)
            
            if classBasedDefaultValue != None:
                stringValue = classBasedDefaultValue
            else:
                raise KeyError(&#34;Key: &#34; + key + &#34; not found in {} or default config values&#34;.format(self.fileName))

        ### Sample from normal distribution if required ###
        if not self.disableDistributionSampling:
            ### Check if a standard deviation has been specified. If so, sample a gaussian distribution before returning the value ###
            stdDevKey = key + &#34;_stdDev&#34;

            # Scalar values
            try:
                mu = float(stringValue)            
                sigma = float(self.getValue(stdDevKey))

                sampledValue = self.rng.gauss(mu, sigma)

                logLine = &#34;Sampling scalar parameter: {}, value: {:1.3f}&#34;.format(key, sampledValue)
                if self.monteCarloLogger != None:
                    self.monteCarloLogger.log(logLine)
                elif not self.silent:
                    print(logLine)


                return str(sampledValue)
            except (KeyError, ValueError):
                # KeyError throws if stdDevKey not present
                # ValueError throws if either conversion to float fails
                pass

            # Vector values
            try:
                muVec = Vector(stringValue)
                sigmaVec = Vector(self.getValue(stdDevKey))

                sampledVec = Vector(*[ self.rng.gauss(mu, sigma) for mu, sigma in zip(muVec, sigmaVec)])

                logLine = &#34;Sampling vector parameter: {}, value: ({:1.3f})&#34;.format(key, sampledVec)
                if self.monteCarloLogger != None:
                    self.monteCarloLogger.log(logLine)
                elif not self.silent:
                    print(logLine)

                return str(sampledVec)
            except (KeyError, ValueError):
                # KeyError throws if stdDevKey not present
                # ValueError throws if either conversion to Vector fails
                pass

        ### Otherwise return original string value ###
        return stringValue

    def setValue(self, key: str, value) -&gt; None:
        &#39;&#39;&#39;
            Will add the entry if it&#39;s not present
        &#39;&#39;&#39;
        # Remove whitespace
        key = key.strip()
        
        self.dict[key] = value

    def removeKey(self, key: str):
        if key in self.dict:
            return self.dict.pop(key)
        else:
            print(&#34;Warning: &#34; + key + &#34; not found, can&#39;t delete&#34;)
            return None

    def setIfAbsent(self, key: str, value):
        &#39;&#39;&#39; Sets a value, only if it doesn&#39;t currently exist in the dictionary &#39;&#39;&#39;
        if not key in self.dict:
            self.setValue(key, value)

    def writeToFile(self, fileName: str, writeHeader=True) -&gt; None:
        &#39;&#39;&#39; 
            Write a (potentially modified) sim definition to file.
            Newly written file will not contain any comments! 
        &#39;&#39;&#39;
        self.fileName = fileName

        with open(fileName, &#39;w&#39;) as file:
            # Extract the fileName from the fileName variable, which may contain other folder names
            dictName = re.sub(&#34;^.*/&#34;, &#34;&#34;, fileName)

            # Write Header
            if writeHeader:
                file.write(&#34;# MAPLEAF\n&#34;)
                file.write(&#34;# File: {}\n&#34;.format(fileName))
                file.write(&#34;# Autowritten on: &#34; + str(datetime.now()) + &#34;\n&#34;)

            # Sorting the keys before iterating through them ensures that dictionaries will be stored together
            sortedDict = sorted(self.dict.items())
            currDicts = []
            for key in sortedDict:
                key = key[0]
                dicts = key.split(&#39;.&#39;)[:-1]

                # Need to get be in the appropriate dictionary before writing the key, value pair
                if dicts != currDicts:
                    
                    #Close any uneeded dictionaries
                    dictDepth = currDicts.__len__()
                    while dictDepth &gt; 0:
                        if dictDepth &gt; dicts.__len__():
                            file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                        elif currDicts[dictDepth-1] != dicts[dictDepth-1]:
                            file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                        else:
                            break
                        
                        dictDepth = dictDepth - 1

                    openedNewDict = False

                    #Open any new dictionaries
                    while dictDepth &lt; dicts.__len__():
                        newDict = dicts[dictDepth]
                        file.write(&#34;\n&#34; + &#34;\t&#34; * dictDepth + newDict + &#34;{\n&#34;)
                        dictDepth = dictDepth + 1
                        openedNewDict = True
                    
                    if not openedNewDict:
                        # If no new dictionary was openend after closing unneeded ones, add a spacing line before writing keys/values
                        file.write(&#34;\n&#34;)

                    currDicts = dicts

                #Add the key, value
                dictDepth = currDicts.__len__()
                realKey = re.sub(&#34;^([^\.]*\.)+&#34;, &#34;&#34;, key)
                file.write( &#34;\t&#34;*dictDepth + realKey + &#34;\t&#34; + self.dict[key] + &#34;\n&#34;)

            #Close any open dictionaries
            dictDepth = currDicts.__len__()
            while dictDepth &gt; 0:
                dictDepth = dictDepth - 1
                file.write(&#34;\t&#34;*dictDepth + &#34;}\n&#34;)

    #### Introspection / Key Gymnastics ####
    def findKeysContaining(self, keyContains: List[str]) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns a list of all keys that contain any of the strings in keyContains
            
            ## Example  
                findKeysContaining([&#34;class&#34;]) -&gt;  
                [ &#34;Rocket.class&#34;, &#34;Rocket.Sustainer.class&#34;, &#34;Rocket.Sustainer.Nosecone.class&#34;, etc... ]
        &#39;&#39;&#39;
        matchingKeys = []
        for key in self.dict.keys():
            match = True
            for str in keyContains:
                if str not in key:
                    match = False
                    break
            
            if match:
                matchingKeys.append(key)
        
        if len(matchingKeys) &gt; 0:
            return matchingKeys
        else:
            return None

    def getSubKeys(self, key: str) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns a list of all keys that are children of key

            ## Example  
                getSubKeys(&#34;Rocket&#34;) -&gt;  
                [ &#34;Rocket.position&#34;, &#34;Rocket.Sustainer.NoseCone.mass&#34;, &#34;Rocket.Sustainer.RecoverySystem.position&#34;, etc... ]
        &#39;&#39;&#39;
        subKeys = []
        for currentKey in self.dict.keys():
            if isSubKey(key, currentKey):
                subKeys.append(currentKey)
        
        return subKeys

    def getImmediateSubKeys(self, key: str) -&gt; List[str]:
        &#34;&#34;&#34; 
            Returns all keys that are immediate children of the parentKey (one &#39;level&#39; lower)
            
            .. note:: Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries

            ## Example:
                getImmediateSubKeys(&#34;Rocket&#34;) -&gt;  
                [ &#34;Rocket.name&#34;, &#34;Rocket.position&#34;, &#34;Rocket.velocity&#34;, etc...]
        &#34;&#34;&#34;
        results = set()
        for potentialChildKey in self.dict.keys():
            # Iterate through all keys - check if they are children of currentPath
            if isSubKey(key, potentialChildKey):
                # If so, get the part of the key that is the immediate child of currentPath
                immediateSubkey = getImmediateSubKey(key, potentialChildKey)
                
                # If we haven&#39;t got it already, save it
                results.add(immediateSubkey)

        return list(results)

    def getImmediateSubDicts(self, key: str) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns list of names of immediate subdictionaries

            ## Example
                getImmediateSubDicts(&#34;Rocket&#34;) -&gt;
                [ &#34;Rocket.StageOne&#34;, &#34;Rocket.StageTwo&#34;, &#34;Rocket.ControlSystem&#34;, etc... ]

            .. note:: This example would not return a dictionry like: &#34;Rocket.StageOne.FinSet&#34; because it&#39;s not an immediate subdictionary of &#34;Rocket&#34;
        &#39;&#39;&#39;
        keyLevel = getKeyLevel(key)
        subKeys = self.getSubKeys(key)

        subDictionaries = set()
        for subKey in subKeys:
            subKeyLevel = getKeyLevel(subKey)
            if subKeyLevel - keyLevel &gt; 1:
                # A subkey would have 1 level higher
                # A subkey of a subdictionary would have 2 levels higher - this is what we&#39;re looking for
                subDictKey = getParentKeyAtLevel(subKey, keyLevel+1)
                subDictionaries.add(subDictKey)
        
        return list(subDictionaries)

    def _getClassBasedDefaultValue(self, key: str) -&gt; Union[str, None]:
        &#39;&#39;&#39; 
            Returns class-based default value from defaultConfigValues if it exists. Otherwise returns None 
            
            Will attempt to find class-based default values for every longer prefixes of a key:
                key = &#34;Rocket.Sustainer.canards.trailingEdge.shape&#34;
                Attempt1 = &#34;Rocket.Sustainer.canards.trailingEdge.class&#34; -&gt; Fail
                Attempt2 = &#34;Rocket.Sustainer.canards.class&#34; -&gt; FinSet -&gt; look up &#39;FinSet.trailingEdge.shape&#39; in defaultDict -&gt; if there, return it, otherwise return None
        &#39;&#39;&#39;
        splitLevel = getKeyLevel(key)

        while splitLevel &gt;= 0:
            prefix, suffix = splitKeyAtLevel(key, splitLevel)
            
            try:
                classKey = prefix + &#34;.class&#34;
                className = self.dict[classKey]                

                # As soon as we arrive at an item with a class, search terminates
                try:
                    classBasedDefaultKey = className + &#34;.&#34; + suffix
                    defaultValue = self.defaultDict[classBasedDefaultKey]

                    # Track that we&#39;ve used a default value
                    if classBasedDefaultKey not in self.defaultValuesUsed:
                        self.defaultValuesUsed.add(classBasedDefaultKey)
                    
                    # if the classKey was useful, count it as &#39;used&#39;
                    if classKey in self.unaccessedFields: 
                        self.unaccessedFields.remove(classKey)
                        
                    return defaultValue
                except KeyError:
                    return None # class-based default value not found
            
            except KeyError:
                pass # prefix.class not present

            # Move one level up the dictionary for next attempt
            splitLevel -= 1
        
        return None

    #### Usage Reporting ####
    def printUnusedKeys(self):
        &#39;&#39;&#39;
            Checks which keys in the present simulation definition have not yet been accessed.
            Prints a list of those to the console.
        &#39;&#39;&#39;
        if len(self.unaccessedFields) &gt; 0:
            print(&#34;\nWarning: The following keys were loaded from: {} but never accessed:&#34;.format(self.fileName))
            for key in sorted(self.unaccessedFields):
                value = self.dict[key]
                print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
            print(&#34;&#34;)

    def printDefaultValuesUsed(self):
        &#39;&#39;&#39;
            Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.
        &#39;&#39;&#39;
        if len(self.defaultValuesUsed):
            print(&#34;\nWarning: The following default values were used in this simulation:&#34;)
            for key in sorted(self.defaultValuesUsed):
                value = self.defaultDict[key]
                print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
            print(&#34;\nIf this was not intended, override the default values by adding the above information to your simulation definition file.\n&#34;)
        
    def _resetUsedAndUnusedKeyTrackers(self):
        # Create a dictionary to keep track of which attributed have been accessed (initially none)
        self.unaccessedFields = set(self.dict.keys())
        # Create a list to track which default values have been used
        self.defaultValuesUsed = set()

    #### Utilities ####
    def __str__(self):
        result = &#34;&#34;
        result += &#34;File: &#34; + self.fileName + &#34;\n&#34;

        for key, value in self.dict.items():
            result += &#34;{}: {}\n&#34;.format(key, value)

        result += &#34;\n&#34;

        return result

    def __eq__ (self, simDef2):
        try:
            if self.dict == simDef2.dict:
                return True
            else:
                return False
        except AttributeError:
            return False</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.defaultDict"><code class="name">var <span class="ident">defaultDict</span></code></dt>
<dd>
<div class="desc"><p>Holds all of the defined default values. These will fill in for missing values in self.dict. Unless a different dictionary is specified, will hold a reference to <code>MAPLEAF.IO.SimDefinition.defaultConfigValues</code></p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.dict"><code class="name">var <span class="ident">dict</span></code></dt>
<dd>
<div class="desc"><p>Main dictionary of values, usually populated from a simulation definition file</p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.disableDistributionSampling"><code class="name">var <span class="ident">disableDistributionSampling</span></code></dt>
<dd>
<div class="desc"><p>Boolean - controls whether parameters which have standard deviations specified are actually sampled from a normal distribution. If True, the mean value is always returned. Chief use case for disabling sampling: Checking simulation convergence as the time step / target error is decreased.</p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.monteCarloLogger"><code class="name">var <span class="ident">monteCarloLogger</span></code></dt>
<dd>
<div class="desc"><p>Filled in by
Main.runMonteCarloSimulation() if running
Monte Carlo simulation. Type: <code>IO.Logging.MonteCarloLogger</code></p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.silent"><code class="name">var <span class="ident">silent</span></code></dt>
<dd>
<div class="desc"><p>Boolean, controls console output</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.findKeysContaining"><code class="name flex">
<span>def <span class="ident">findKeysContaining</span></span>(<span>self, keyContains: List[str]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all keys that contain any of the strings in keyContains</p>
<h2 id="example">Example</h2>
<pre><code>findKeysContaining(["class"]) -&gt;  
[ "Rocket.class", "Rocket.Sustainer.class", "Rocket.Sustainer.Nosecone.class", etc... ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findKeysContaining(self, keyContains: List[str]) -&gt; List[str]:
    &#39;&#39;&#39;
        Returns a list of all keys that contain any of the strings in keyContains
        
        ## Example  
            findKeysContaining([&#34;class&#34;]) -&gt;  
            [ &#34;Rocket.class&#34;, &#34;Rocket.Sustainer.class&#34;, &#34;Rocket.Sustainer.Nosecone.class&#34;, etc... ]
    &#39;&#39;&#39;
    matchingKeys = []
    for key in self.dict.keys():
        match = True
        for str in keyContains:
            if str not in key:
                match = False
                break
        
        if match:
            matchingKeys.append(key)
    
    if len(matchingKeys) &gt; 0:
        return matchingKeys
    else:
        return None</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.getImmediateSubDicts"><code class="name flex">
<span>def <span class="ident">getImmediateSubDicts</span></span>(<span>self, key: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of names of immediate subdictionaries</p>
<h2 id="example">Example</h2>
<pre><code>getImmediateSubDicts("Rocket") -&gt;
[ "Rocket.StageOne", "Rocket.StageTwo", "Rocket.ControlSystem", etc... ]
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This example would not return a dictionry like: "Rocket.StageOne.FinSet" because it's not an immediate subdictionary of "Rocket"</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubDicts(self, key: str) -&gt; List[str]:
    &#39;&#39;&#39;
        Returns list of names of immediate subdictionaries

        ## Example
            getImmediateSubDicts(&#34;Rocket&#34;) -&gt;
            [ &#34;Rocket.StageOne&#34;, &#34;Rocket.StageTwo&#34;, &#34;Rocket.ControlSystem&#34;, etc... ]

        .. note:: This example would not return a dictionry like: &#34;Rocket.StageOne.FinSet&#34; because it&#39;s not an immediate subdictionary of &#34;Rocket&#34;
    &#39;&#39;&#39;
    keyLevel = getKeyLevel(key)
    subKeys = self.getSubKeys(key)

    subDictionaries = set()
    for subKey in subKeys:
        subKeyLevel = getKeyLevel(subKey)
        if subKeyLevel - keyLevel &gt; 1:
            # A subkey would have 1 level higher
            # A subkey of a subdictionary would have 2 levels higher - this is what we&#39;re looking for
            subDictKey = getParentKeyAtLevel(subKey, keyLevel+1)
            subDictionaries.add(subDictKey)
    
    return list(subDictionaries)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.getImmediateSubKeys"><code class="name flex">
<span>def <span class="ident">getImmediateSubKeys</span></span>(<span>self, key: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all keys that are immediate children of the parentKey (one 'level' lower)</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries</p>
</div>
<h2 id="example">Example:</h2>
<pre><code>getImmediateSubKeys("Rocket") -&gt;  
[ "Rocket.name", "Rocket.position", "Rocket.velocity", etc...]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubKeys(self, key: str) -&gt; List[str]:
    &#34;&#34;&#34; 
        Returns all keys that are immediate children of the parentKey (one &#39;level&#39; lower)
        
        .. note:: Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries

        ## Example:
            getImmediateSubKeys(&#34;Rocket&#34;) -&gt;  
            [ &#34;Rocket.name&#34;, &#34;Rocket.position&#34;, &#34;Rocket.velocity&#34;, etc...]
    &#34;&#34;&#34;
    results = set()
    for potentialChildKey in self.dict.keys():
        # Iterate through all keys - check if they are children of currentPath
        if isSubKey(key, potentialChildKey):
            # If so, get the part of the key that is the immediate child of currentPath
            immediateSubkey = getImmediateSubKey(key, potentialChildKey)
            
            # If we haven&#39;t got it already, save it
            results.add(immediateSubkey)

    return list(results)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.getSubKeys"><code class="name flex">
<span>def <span class="ident">getSubKeys</span></span>(<span>self, key: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all keys that are children of key</p>
<h2 id="example">Example</h2>
<pre><code>getSubKeys("Rocket") -&gt;  
[ "Rocket.position", "Rocket.Sustainer.NoseCone.mass", "Rocket.Sustainer.RecoverySystem.position", etc... ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSubKeys(self, key: str) -&gt; List[str]:
    &#39;&#39;&#39;
        Returns a list of all keys that are children of key

        ## Example  
            getSubKeys(&#34;Rocket&#34;) -&gt;  
            [ &#34;Rocket.position&#34;, &#34;Rocket.Sustainer.NoseCone.mass&#34;, &#34;Rocket.Sustainer.RecoverySystem.position&#34;, etc... ]
    &#39;&#39;&#39;
    subKeys = []
    for currentKey in self.dict.keys():
        if isSubKey(key, currentKey):
            subKeys.append(currentKey)
    
    return subKeys</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self, key: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><h2 id="input">Input</h2>
<p>Key should be a string of format "DictionaryName.SubdictionaryName.Key"</p>
<h2 id="output">Output</h2>
<p>Always returns a string value
Returns value from defaultConfigValues if key not present in current SimDefinition's dictionary</p>
<p>Normal Distribution Sampling:
If (key + "_stdDev") exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
Where the mean of the normal distribution is taken to be the value of 'key' and the standard deviation of the distribution is the value of 'key_stdDev'
For a vector value, a vector of standard deviations is expected
For repeatable sampling, set the value "MonteCarlo.randomSeed" in the file loaded by this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(self, key: str) -&gt; str:
    &#34;&#34;&#34;
        Input:
            Key should be a string of format &#34;DictionaryName.SubdictionaryName.Key&#34;
        Output:
            Always returns a string value
            Returns value from defaultConfigValues if key not present in current SimDefinition&#39;s dictionary

            Normal Distribution Sampling:
                If (key + &#34;_stdDev&#34;) exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
                    Where the mean of the normal distribution is taken to be the value of &#39;key&#39; and the standard deviation of the distribution is the value of &#39;key_stdDev&#39;
                    For a vector value, a vector of standard deviations is expected
                For repeatable sampling, set the value &#34;MonteCarlo.randomSeed&#34; in the file loaded by this class
    &#34;&#34;&#34;
    # Remove any whitespace from the key
    key = key.strip()

    ### Find string/mean value ###
    if self.dict.__contains__(key):
        stringValue = self.dict[key]

        if key in self.unaccessedFields: # Track which keys are accessed
            self.unaccessedFields.remove(key)
    elif key in self.defaultDict:
        stringValue = self.defaultDict[key]
        self.defaultValuesUsed.add(key)
    else:
        # Check if there&#39;s a class-based default value to return
        classBasedDefaultValue = self._getClassBasedDefaultValue(key)
        
        if classBasedDefaultValue != None:
            stringValue = classBasedDefaultValue
        else:
            raise KeyError(&#34;Key: &#34; + key + &#34; not found in {} or default config values&#34;.format(self.fileName))

    ### Sample from normal distribution if required ###
    if not self.disableDistributionSampling:
        ### Check if a standard deviation has been specified. If so, sample a gaussian distribution before returning the value ###
        stdDevKey = key + &#34;_stdDev&#34;

        # Scalar values
        try:
            mu = float(stringValue)            
            sigma = float(self.getValue(stdDevKey))

            sampledValue = self.rng.gauss(mu, sigma)

            logLine = &#34;Sampling scalar parameter: {}, value: {:1.3f}&#34;.format(key, sampledValue)
            if self.monteCarloLogger != None:
                self.monteCarloLogger.log(logLine)
            elif not self.silent:
                print(logLine)


            return str(sampledValue)
        except (KeyError, ValueError):
            # KeyError throws if stdDevKey not present
            # ValueError throws if either conversion to float fails
            pass

        # Vector values
        try:
            muVec = Vector(stringValue)
            sigmaVec = Vector(self.getValue(stdDevKey))

            sampledVec = Vector(*[ self.rng.gauss(mu, sigma) for mu, sigma in zip(muVec, sigmaVec)])

            logLine = &#34;Sampling vector parameter: {}, value: ({:1.3f})&#34;.format(key, sampledVec)
            if self.monteCarloLogger != None:
                self.monteCarloLogger.log(logLine)
            elif not self.silent:
                print(logLine)

            return str(sampledVec)
        except (KeyError, ValueError):
            # KeyError throws if stdDevKey not present
            # ValueError throws if either conversion to Vector fails
            pass

    ### Otherwise return original string value ###
    return stringValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.printDefaultValuesUsed"><code class="name flex">
<span>def <span class="ident">printDefaultValuesUsed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printDefaultValuesUsed(self):
    &#39;&#39;&#39;
        Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.
    &#39;&#39;&#39;
    if len(self.defaultValuesUsed):
        print(&#34;\nWarning: The following default values were used in this simulation:&#34;)
        for key in sorted(self.defaultValuesUsed):
            value = self.defaultDict[key]
            print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
        print(&#34;\nIf this was not intended, override the default values by adding the above information to your simulation definition file.\n&#34;)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.printUnusedKeys"><code class="name flex">
<span>def <span class="ident">printUnusedKeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks which keys in the present simulation definition have not yet been accessed.
Prints a list of those to the console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printUnusedKeys(self):
    &#39;&#39;&#39;
        Checks which keys in the present simulation definition have not yet been accessed.
        Prints a list of those to the console.
    &#39;&#39;&#39;
    if len(self.unaccessedFields) &gt; 0:
        print(&#34;\nWarning: The following keys were loaded from: {} but never accessed:&#34;.format(self.fileName))
        for key in sorted(self.unaccessedFields):
            value = self.dict[key]
            print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
        print(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.removeKey"><code class="name flex">
<span>def <span class="ident">removeKey</span></span>(<span>self, key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeKey(self, key: str):
    if key in self.dict:
        return self.dict.pop(key)
    else:
        print(&#34;Warning: &#34; + key + &#34; not found, can&#39;t delete&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.setIfAbsent"><code class="name flex">
<span>def <span class="ident">setIfAbsent</span></span>(<span>self, key: str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a value, only if it doesn't currently exist in the dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setIfAbsent(self, key: str, value):
    &#39;&#39;&#39; Sets a value, only if it doesn&#39;t currently exist in the dictionary &#39;&#39;&#39;
    if not key in self.dict:
        self.setValue(key, value)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.setValue"><code class="name flex">
<span>def <span class="ident">setValue</span></span>(<span>self, key: str, value) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Will add the entry if it's not present</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setValue(self, key: str, value) -&gt; None:
    &#39;&#39;&#39;
        Will add the entry if it&#39;s not present
    &#39;&#39;&#39;
    # Remove whitespace
    key = key.strip()
    
    self.dict[key] = value</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.SimDefinition.writeToFile"><code class="name flex">
<span>def <span class="ident">writeToFile</span></span>(<span>self, fileName: str, writeHeader=True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write a (potentially modified) sim definition to file.
Newly written file will not contain any comments!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeToFile(self, fileName: str, writeHeader=True) -&gt; None:
    &#39;&#39;&#39; 
        Write a (potentially modified) sim definition to file.
        Newly written file will not contain any comments! 
    &#39;&#39;&#39;
    self.fileName = fileName

    with open(fileName, &#39;w&#39;) as file:
        # Extract the fileName from the fileName variable, which may contain other folder names
        dictName = re.sub(&#34;^.*/&#34;, &#34;&#34;, fileName)

        # Write Header
        if writeHeader:
            file.write(&#34;# MAPLEAF\n&#34;)
            file.write(&#34;# File: {}\n&#34;.format(fileName))
            file.write(&#34;# Autowritten on: &#34; + str(datetime.now()) + &#34;\n&#34;)

        # Sorting the keys before iterating through them ensures that dictionaries will be stored together
        sortedDict = sorted(self.dict.items())
        currDicts = []
        for key in sortedDict:
            key = key[0]
            dicts = key.split(&#39;.&#39;)[:-1]

            # Need to get be in the appropriate dictionary before writing the key, value pair
            if dicts != currDicts:
                
                #Close any uneeded dictionaries
                dictDepth = currDicts.__len__()
                while dictDepth &gt; 0:
                    if dictDepth &gt; dicts.__len__():
                        file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                    elif currDicts[dictDepth-1] != dicts[dictDepth-1]:
                        file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                    else:
                        break
                    
                    dictDepth = dictDepth - 1

                openedNewDict = False

                #Open any new dictionaries
                while dictDepth &lt; dicts.__len__():
                    newDict = dicts[dictDepth]
                    file.write(&#34;\n&#34; + &#34;\t&#34; * dictDepth + newDict + &#34;{\n&#34;)
                    dictDepth = dictDepth + 1
                    openedNewDict = True
                
                if not openedNewDict:
                    # If no new dictionary was openend after closing unneeded ones, add a spacing line before writing keys/values
                    file.write(&#34;\n&#34;)

                currDicts = dicts

            #Add the key, value
            dictDepth = currDicts.__len__()
            realKey = re.sub(&#34;^([^\.]*\.)+&#34;, &#34;&#34;, key)
            file.write( &#34;\t&#34;*dictDepth + realKey + &#34;\t&#34; + self.dict[key] + &#34;\n&#34;)

        #Close any open dictionaries
        dictDepth = currDicts.__len__()
        while dictDepth &gt; 0:
            dictDepth = dictDepth - 1
            file.write(&#34;\t&#34;*dictDepth + &#34;}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.IO" href="index.html">MAPLEAF.IO</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="MAPLEAF.IO.SimDefinition.getAbsoluteFilePath" href="#MAPLEAF.IO.SimDefinition.getAbsoluteFilePath">getAbsoluteFilePath</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getImmediateSubKey" href="#MAPLEAF.IO.SimDefinition.getImmediateSubKey">getImmediateSubKey</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getKeyLevel" href="#MAPLEAF.IO.SimDefinition.getKeyLevel">getKeyLevel</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getParentKeyAtLevel" href="#MAPLEAF.IO.SimDefinition.getParentKeyAtLevel">getParentKeyAtLevel</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.isSubKey" href="#MAPLEAF.IO.SimDefinition.isSubKey">isSubKey</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.splitKeyAtLevel" href="#MAPLEAF.IO.SimDefinition.splitKeyAtLevel">splitKeyAtLevel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition" href="#MAPLEAF.IO.SimDefinition.SimDefinition">SimDefinition</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.defaultDict" href="#MAPLEAF.IO.SimDefinition.SimDefinition.defaultDict">defaultDict</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.dict" href="#MAPLEAF.IO.SimDefinition.SimDefinition.dict">dict</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.disableDistributionSampling" href="#MAPLEAF.IO.SimDefinition.SimDefinition.disableDistributionSampling">disableDistributionSampling</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.findKeysContaining" href="#MAPLEAF.IO.SimDefinition.SimDefinition.findKeysContaining">findKeysContaining</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.getImmediateSubDicts" href="#MAPLEAF.IO.SimDefinition.SimDefinition.getImmediateSubDicts">getImmediateSubDicts</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.getImmediateSubKeys" href="#MAPLEAF.IO.SimDefinition.SimDefinition.getImmediateSubKeys">getImmediateSubKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.getSubKeys" href="#MAPLEAF.IO.SimDefinition.SimDefinition.getSubKeys">getSubKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.getValue" href="#MAPLEAF.IO.SimDefinition.SimDefinition.getValue">getValue</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.monteCarloLogger" href="#MAPLEAF.IO.SimDefinition.SimDefinition.monteCarloLogger">monteCarloLogger</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.printDefaultValuesUsed" href="#MAPLEAF.IO.SimDefinition.SimDefinition.printDefaultValuesUsed">printDefaultValuesUsed</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.printUnusedKeys" href="#MAPLEAF.IO.SimDefinition.SimDefinition.printUnusedKeys">printUnusedKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.removeKey" href="#MAPLEAF.IO.SimDefinition.SimDefinition.removeKey">removeKey</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.setIfAbsent" href="#MAPLEAF.IO.SimDefinition.SimDefinition.setIfAbsent">setIfAbsent</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.setValue" href="#MAPLEAF.IO.SimDefinition.SimDefinition.setValue">setValue</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.silent" href="#MAPLEAF.IO.SimDefinition.SimDefinition.silent">silent</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.SimDefinition.writeToFile" href="#MAPLEAF.IO.SimDefinition.SimDefinition.writeToFile">writeToFile</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>